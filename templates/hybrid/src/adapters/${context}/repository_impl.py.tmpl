from typing import Sequence
from uuid import UUID
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.adapters.${context}.models import ${ContextCap}Model
from app.adapters.${context}.mappers import to_domain, to_model, update_model
from app.domain.${context}.entities import ${ContextCap}
from app.domain.${context}.repositories import ${ContextCap}Repository

class SqlAlchemy${ContextCap}Repository(${ContextCap}Repository):
    def __init__(self, session: AsyncSession):
        self._session = session
    
    async def add(self, entity: ${ContextCap}) -> None:
        model = to_model(entity)
        self._session.add(model)
        await self._session.flush()
    
    async def get(self, id: UUID) -> ${ContextCap} | None:
        stmt = select(${ContextCap}Model).where(${ContextCap}Model.id == str(id))
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return to_domain(model) if model else None
    
    async def by_email(self, email: str) -> ${ContextCap} | None:
        stmt = select(${ContextCap}Model).where(${ContextCap}Model.email == email)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return to_domain(model) if model else None
    
    async def list(self, limit: int = 50, offset: int = 0) -> Sequence[${ContextCap}]:
        stmt = select(${ContextCap}Model).offset(offset).limit(limit)
        result = await self._session.execute(stmt)
        models = result.scalars().all()
        return [to_domain(m) for m in models]
    
    async def update(self, entity: ${ContextCap}) -> None:
        stmt = select(${ContextCap}Model).where(${ContextCap}Model.id == str(entity.id))
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        
        if not model:
            raise ValueError(f"${ContextCap} {entity.id} n√£o encontrado")
        
        update_model(model, entity)
        await self._session.flush()
