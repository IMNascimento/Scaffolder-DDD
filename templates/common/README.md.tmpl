# ${project_name}

> FastAPI Multi-Architecture Scaffolder — **${arch}** + **${orm}** on **${db}**  
> Pacote Python: **${module_name}** · API prefix: **${api_prefix}**

Este repositório foi gerado pelo *foundry.py*. Ele segue o layout **src/** com um pacote Python real chamado **`${module_name}`**, garantindo imports estáveis (dev = prod) e organização por arquitetura e *bounded contexts* (`${contexts}`).

---

## 📦 Estrutura (resumo)

```
${project_name}/
├─ src/
│  └─ ${module_name}/
│     ├─ api/                 # Entrypoints HTTP (FastAPI), rotas, DTOs
│     ├─ application/         # Casos de uso, orquestração
│     ├─ core/                # Config, db, settings, logging, erros
│     ├─ domain/              # Entidades, VOs, portas (ports), regras de negócio
│     ├─ infrastructure/      # Adapters (repo, gateways, orm) [varia por arquitetura]
│     └─ __init__.py
├─ scripts/                   # sh/bat auxiliares (dev, lint, test, migrate)
├─ tests/                     # Testes (pytest)
├─ .env.example               # Exemplo de variáveis de ambiente
├─ docker-compose.yml         # (opcional) Banco e app em containers
├─ Dockerfile                 # Build da aplicação
├─ pyproject.toml             # Ruff/MyPy/poetry/setuptools (conforme template)
└─ README.md
```

> **Observação:** Dependendo da arquitetura escolhida (`${arch}`), alguns diretórios podem ter nomes levemente diferentes (ex.: `adapters/`, `infrastructure/`).

---

## 🔧 Pré-requisitos

- Python **3.12+**
- (Opcional) Docker + Docker Compose
- (Opcional) `make` (Linux/Mac) ou Git Bash no Windows

---

## 🚀 Setup rápido (dev)

### 1) Criar e ativar o ambiente virtual
```bash
python -m venv .venv
# Linux/Mac
source .venv/bin/activate
# Windows (PowerShell)
# .venv\Scripts\Activate.ps1
```

### 2) Instalar dependências
Há duas formas. Recomendamos **editable install** para habilitar imports estáveis do pacote `${module_name}`.

**Opção A — Editable install (recomendada)**
```bash
pip install -U pip
pip install -r requirements.txt
pip install -e .
```
Isso instala `${module_name}` no modo desenvolvimento. Assim, em qualquer lugar (incluindo `tests/`) você pode fazer:
```python
from ${module_name}.core.settings import Settings
```

**Opção B — Apenas requirements (funciona, mas menos robusta)**
```bash
pip install -U pip
pip install -r requirements.txt
# (se optar por essa, configure PYTHONPATH=./src ao rodar scripts)
```

### 3) Configurar variáveis de ambiente
Crie um `.env` a partir do exemplo e ajuste o que for necessário:
```bash
cp .env.example .env
```
Campos comuns (exemplo — pode variar por template):
```
APP_ENV=dev
API_PREFIX=${api_prefix}
DATABASE_URL=${db}://${module_name}:password@localhost:5432/${project_name}
# ou use a URL gerada pelo foundry: ${db_url}
```

### 4) (Opcional) Subir infraestrutura com Docker
```bash
docker compose up -d --build
```
O compose geralmente sobe um banco (`${db}`) e, se configurado, a app.

### 5) Criar/rodar migrações (SQLAlchemy + Alembic)
Se o template usar SQLAlchemy + Alembic:
```bash
./scripts/migrate.sh
# ou manualmente:
# alembic revision -m "init"
# alembic upgrade head
```

### 6) Rodar em modo desenvolvimento
```bash
./scripts/dev.sh
# ou
uvicorn ${module_name}.api.main:app --reload --host 0.0.0.0 --port 8000
```

Abra:
- Swagger UI: `http://localhost:8000${api_prefix}/docs`
- Redoc: `http://localhost:8000${api_prefix}/redoc`

---

## 🧭 Convenções de import

Este projeto usa **src layout** com pacote `${module_name}`. Sempre importe a partir de `${module_name}.…`:
```python
from ${module_name}.domain.payment.entities import Payment
from ${module_name}.application.payment.use_cases.create_payment import CreatePayment
from ${module_name}.core.errors import NotFoundError
```
> Evite `from app.…`. O gerador já tenta corrigir *templates* legados, mas o ideal é manter `${module_name}` nos novos arquivos.

---

## 🧪 Testes e cobertura

### Rodar testes
```bash
pytest -v
```

### Cobertura (threshold configurável no `pytest.ini`)
```bash
pytest --cov=${module_name} --cov-report=term-missing --cov-report=html
# Relatório HTML em: htmlcov/index.html
```

---

## ✅ Qualidade (Ruff, MyPy, pre-commit)

### Lint e format
```bash
ruff check . --fix
ruff format .
```

### Tipos (MyPy)
```bash
mypy src/${module_name} tests
```

### Hooks de commit
```bash
pre-commit install
pre-commit run -a
```

---

## 🧱 Scripts úteis

Se presentes (podem variar conforme template):

```bash
./scripts/dev.sh        # uvicorn com reload
./scripts/migrate.sh    # migrações (alembic)
./scripts/test.sh       # pytest + cobertura
./scripts/lint.sh       # ruff + mypy
./scripts/wait-for-db.sh
```

No Windows, rode via Git Bash ou adapte para `.bat/.ps1`.

---

## 🧩 Arquitetura & Contextos

O *foundry* suporta múltiplos *bounded contexts* (ex.: `payment`, `sales`) e diferentes estilos arquiteturais:
- **DDD / Hybrid**: `domain/` com entidades/VOs/ports e `application/` para casos de uso; `infrastructure/` para adapters e persistência.
- **Hexagonal**: separação explícita de *adapters* inbound/outbound e ports.
- **MVC**: mais direto, com camadas simplificadas.

Os contextos são expandidos a partir de `${contexts}` no momento da geração; arquivos de *use cases*, *entities*, *ports* e *repositories* são criados em seus respectivos diretórios.

---

## 🗄️ Persistência

- **ORM**: `${orm}`
- **Banco**: `${db}`

A URL padrão é inferida pelo *foundry*. Você pode alterá-la em `.env`:
```
DATABASE_URL=${db}://${module_name}:password@localhost:5432/${project_name}
# exemplo para PostgreSQL (async):
# postgresql+asyncpg://postgres:postgres@localhost:5432/${project_name}
```

Se usar SQLAlchemy + Alembic, verifique o arquivo `alembic/env.py` — o *foundry* injeta o `target_metadata` a partir de `${module_name}.core.db` e importa os modelos por contexto.

---

## 🛡️ Logs & Config

- Configurações centralizadas em `${module_name}.core.settings` (Pydantic Settings).
- Logging estruturado (structlog) em `${module_name}.core.logging` (se incluído pelo template).
- Exceções comuns em `${module_name}.core.errors`.

---

## 🧪 Exemplo mínimo (hello route)

> Dependendo do template, você terá algo como:

```python
# src/${module_name}/api/main.py
from fastapi import FastAPI

app = FastAPI(title="${project_name}")

@app.get("${api_prefix}/health")
def health():
    return {"status": "ok"}
```

Rode:
```bash
uvicorn ${module_name}.api.main:app --reload
```

---

## 🛠️ Comandos úteis (cheat sheet)

```bash
# 1) Ambiente
python -m venv .venv && source .venv/bin/activate
pip install -U pip && pip install -r requirements.txt && pip install -e .

# 2) Infra (opcional)
docker compose up -d --build

# 3) Migração (se Alembic)
alembic upgrade head

# 4) Dev server
uvicorn ${module_name}.api.main:app --reload

# 5) Qualidade
ruff check . --fix && ruff format . && mypy src/${module_name}

# 6) Testes
pytest -v --cov=${module_name} --cov-report=term-missing
```

---

## 📄 Licença

Este projeto pode incluir um arquivo `LICENSE` conforme o template selecionado. Ajuste conforme necessário.

---

## 💬 Suporte

Abra uma *issue* descrevendo problemas ou melhorias. Sugestões são bem-vindas!

## 👤 Autor

- **Igor Nascimento** – Desenvolvedor Principal – [GitHub](https://github.com/IMNascimento)

## 🙏 Agradecimentos

- [FastAPI](https://fastapi.tiangolo.com/)  
- [SQLAlchemy](https://www.sqlalchemy.org/)  
- [Alembic](https://alembic.sqlalchemy.org/)  
- Comunidade DDD & Python por inspiração
- SophiaLabs (https://www.sophialabs.com.br) pelo apoio ao projeto e sempre apoiar iniciativas open source!

