from __future__ import annotations
from typing import Sequence
from uuid import UUID

from peewee import fn
from peewee_async import Manager

from ${module_name}.${shared_pkg}.${context}.models import ${ContextCap}Model
from ${module_name}.${shared_pkg}.${context}.mappers import to_domain, to_model, update_model
from ${module_name}.domain.${context}.entities import ${ContextCap}
from ${module_name}.domain.${context}.repositories import ${ContextCap}Repository


class PW${ContextCap}Repository(${ContextCap}Repository):
    def __init__(self, manager: Manager):
        self._mgr = manager

    async def add(self, entity: ${ContextCap}) -> None:
        # Se seu to_model retorna uma instância de Model, use .save()
        model = to_model(entity)
        await self._mgr.create(${ContextCap}Model, **model.__data__)

    async def get(self, id: UUID) -> ${ContextCap} | None:
        model = await self._mgr.get_or_none(${ContextCap}Model, id=str(id))
        return to_domain(model) if model else None

    async def by_email(self, email: str) -> ${ContextCap} | None:
        model = await self._mgr.get_or_none(${ContextCap}Model, email=email)
        return to_domain(model) if model else None

    async def list(self, limit: int = 50, offset: int = 0) -> Sequence[${ContextCap}]:
        query = ${ContextCap}Model.select().offset(offset).limit(limit)
        models = await self._mgr.execute(query)
        return [to_domain(m) for m in models]

    async def update(self, entity: ${ContextCap}) -> None:
        model = await self._mgr.get_or_none(${ContextCap}Model, id=str(entity.id))
        if not model:
            raise ValueError(f"${ContextCap} {entity.id} não encontrado")
        update_model(model, entity)
        # Peewee: update explícito
        await self._mgr.update(model)
