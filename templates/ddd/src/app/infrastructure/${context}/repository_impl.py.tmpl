from __future__ import annotations
from typing import Iterable
from uuid import UUID
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from ${module_name}.infrastructure.${context}.models import ${ContextCap}Model
from ${module_name}.infrastructure.${context}.mappers import to_domain, to_model
from ${module_name}.domain.${context}.entities import ${ContextCap}
from ${module_name}.domain.${context}.repositories import ${ContextCap}Repository

class SqlAlchemy${ContextCap}Repository(${ContextCap}Repository):
    def __init__(self, session: AsyncSession):
        self.session = session

    async def add(self, c: ${ContextCap}) -> None:
        self.session.add(to_model(c))
        await self.session.flush()

    async def get(self, id: UUID) -> ${ContextCap} | None:
        res = await self.session.execute(select(${ContextCap}Model).where(${ContextCap}Model.id == str(id)))
        m = res.scalar_one_or_none()
        return to_domain(m) if m else None

    async def by_email(self, email: str) -> ${ContextCap} | None:
        res = await self.session.execute(select(${ContextCap}Model).where(${ContextCap}Model.email == email))
        m = res.scalar_one_or_none()
        return to_domain(m) if m else None

    async def list(self, limit: int = 50, offset: int = 0) -> Iterable[${ContextCap}]:
        res = await self.session.execute(select(${ContextCap}Model).offset(offset).limit(limit))
        return [to_domain(m) for m in res.scalars().all()]